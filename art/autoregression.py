import manim as mn


class AutoregressiveGeneration(mn.Scene):
    """Visualization of autoregressive text generation using Manim."""

    def construct(self) -> None:
        """Builds the animation step by step."""
        # Raw text (prompt)
        raw_text = mn.Text('"The quick brown"', font_size=28)
        raw_text.to_corner(mn.DOWN + mn.LEFT)
        raw_text.shift(mn.RIGHT * 0.3)

        # Cursor for typing animation
        cursor = mn.Rectangle(
            color=mn.GREY_A,
            fill_color=mn.GREY_A,
            fill_opacity=1.0,
            height=0.4,
            width=0.2,
        )
        cursor.move_to(raw_text[0].get_bottom())
        cursor.shift(mn.DOWN * 0.05)

        # Step 1: Big transformer rectangle appears and cursor blinks
        transformer_box = mn.RoundedRectangle(width=13, height=3, color=mn.GREEN, corner_radius=0.2)
        transformer_box.to_edge(mn.LEFT, buff=0.2)
        transformer_box.shift(mn.UP * 0.3)
        transformer_text = mn.Text("Transformer", font_size=24)
        transformer_text.move_to(transformer_box.get_center())
        transformer_box.add(transformer_text)
        self.play(mn.DrawBorderThenFill(transformer_box, run_time=4), mn.Blink(cursor, blinks=4))

        self.play(mn.TypeWithCursor(raw_text, cursor))
        self.play(mn.FadeOut(cursor))

        # Step 3: Tokenize text into token IDs
        token_ids = ["9", "203", "3107"]
        token_rectangles = []
        for token in token_ids:
            rectangle = mn.Rectangle(width=1.2, height=0.8, color=mn.BLUE)
            rectangle.add(mn.Text(token, font_size=24))
            token_rectangles.append(rectangle)

        token_boxes = mn.VGroup(*token_rectangles).arrange(mn.RIGHT, buff=0.3)
        token_boxes.next_to(raw_text, mn.UP, buff=0.8)

        tokenizer_arrow = mn.Arrow(
            start=raw_text.get_top(),
            end=token_boxes.get_bottom(),
            buff=0.2,
        )
        tokenizer_label = mn.Text("Tokenization", font_size=20).next_to(tokenizer_arrow, mn.RIGHT)
        tokenizer_arrow.add(tokenizer_label)

        self.play(mn.GrowArrow(tokenizer_arrow))
        self.play(mn.LaggedStart(*[mn.FadeIn(box) for box in token_boxes], lag_ratio=0.2))

        self.wait(1)

        # Step 4: Generating next tokens
        output_token_ids = ["645", "123", "52", "9", "930", "79"]
        output_texts = ["fox", "jumps", "over", "the", "lazy", "dog"]
        output_rectangles, appended_rectangles = [], []
        for token in output_token_ids:
            # Token ids generated by the Transformer
            rectangle_out = mn.Rectangle(width=1.2, height=0.8, color=mn.YELLOW)
            rectangle_out.add(mn.Text(token, font_size=24))
            output_rectangles.append(rectangle_out)
            # Token ids re-used for NTP
            rectangle_app = mn.Rectangle(width=1.2, height=0.8, color=mn.BLUE_B)
            rectangle_app.add(mn.Text(token, font_size=24))
            appended_rectangles.append(rectangle_app)

        output_boxes = mn.VGroup(*output_rectangles).arrange(mn.RIGHT, buff=0.3)
        output_boxes.next_to(token_boxes[-2], mn.RIGHT, buff=0.3)
        output_boxes.set_y(transformer_box.get_top()[1] + 0.8)

        # Add decoded text to output boxes
        for i, text in enumerate(output_texts):
            token_text = mn.Text(f'"{text}"', font_size=20).next_to(output_rectangles[i], mn.UP)
            output_rectangles[i].add(token_text)

        appended_boxes = mn.VGroup(*appended_rectangles).arrange(mn.RIGHT, buff=0.3)
        appended_boxes.next_to(token_boxes[-1], mn.RIGHT, buff=0.3)

        # Autoregressive generation
        for i in range(len(output_boxes)):
            # Little pulse for style
            self.play(
                *(
                    [box.animate.scale(1.12) for box in token_boxes]
                    + [box.animate.scale(1.12) for box in appended_boxes[:i]]
                ),
                run_time=0.25,
                rate_func=mn.rate_functions.there_and_back,
            )

            # Output appears from the model
            appearance_point = output_boxes[i].get_bottom()
            appearance_point[1] -= 0.4
            self.play(
                mn.LaggedStart(
                    *[mn.GrowFromPoint(output_boxes[i], appearance_point)],
                    lag_ratio=0.2,
                ),
            )
            self.wait(1)

            if i == len(output_boxes) - 1:
                break

            # Append the output to the input sequence
            self.play(
                mn.LaggedStart(
                    *[mn.GrowFromPoint(appended_boxes[i], output_boxes[i].get_bottom())],
                    lag_ratio=0.2,
                ),
            )
            self.wait(1)

        self.wait(4)
